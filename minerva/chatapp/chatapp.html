<!doctype html>
<html>
<head>
	<meta http-equiv="charset" content="text/html; charset=utf-8">
	<title></title>
	<style>
		{{ getTestPageCSS() }}

		#controls tr td {
			padding: 0.5em 0 0.5em 0;
		}
	</style>
</head>
<body>

<div id="info">
<p>
This page supports options ?mode=http, ?mode=flash, ?useSub=0, ?useSub=1
(which can be combined).  Note: when using subdomains, you'll see fewer log
messages because log messages in the iframes are not sent to this parent window.
When testing with Opera, open the Error Console, because window.onerror does
not work in Opera.
</p>

Do all of these when testing:
<ul>
<li>Test this page with ?mode=flash.</li>
<li>Test this page with ?mode=http&useSub=0.</li>
<li>Test this page with ?mode=http&useSub=1.</li>
<li>This server listens on both HTTP and HTTPS. Repeat above tests with both HTTP and HTTPS.</li>
<li>For mode=http&useSub=1 : Reload this page with F5.  Firefox 3+ has problems related to this.</li>
<li>For mode=http&useSub=1 : Arrive to this page via Back button from another page.  IE has problems related to this.</li>
<li>For mode=flash : Arrive to this page via Back button from another page.  Opera has problems related to this.</li>
<li>Load the page in a WebKit browser, make sure the spinner stops spinning after 4 seconds.</li>
</ul>
</div>

<table id="controls">
<tr>
	<td>Reconnect:</td>
	<td>
		<input type="submit" value="Reset" onclick="chatapp.resetStream('because user clicked button');return false">
		<input type="submit" value="Reset and connect new stream" onclick="chatapp.reconnectStream();return false">
	</td>
</tr>
<tr>
<td>
	Send text:
</td>
<td>
	<input type="text" name="textinput" id="textinput">
	<input type="submit" value="Send" onclick="chatapp.sendText(byId('textinput').value);return false">
</td>
</tr>
</table>

<!--
Think about this: if in the future we have cross-tab sharing
working with named-window grabbing and SharedWorker, do we
really want to dump two iframes and two DNS requests on the user
for each page they load?  That seems kind of bad.  We should try
to connect to other tabs first, then create an iframe.

To combine the best of both worlds: leave a cookie that indicates
whether there is probably an already-connected Stream in a tab.
If no such cookie, write out the iframes immediately.
-->
<script>
// Don't define variables on "window" to avoid possible IE stack limit of 12
// when calling through window.
CSRF_TOKEN = {{ dumps(token) }};
__XDRSetup = {
	domain: {{ dumps(domain) }},
	sub1: {{ dumps(sub1) }},
	sub2: {{ dumps(sub2) }}
};
</script>

<div id="minerva-xdrframes"></div>
<script src="/JSPATH/cw/net/bootstrap_XDRSetup.js"></script>

<div id="FlashConnectorSwf"></div>
<div id="log"></div>

<script src="/JSPATH/closure/goog/base.js"></script>
<script src="/JSPATH/nongoog_deps.js"></script>
<script>
goog.provide('chatapp');

goog.require('cw.autoTitle');
goog.require('goog.debug.DivConsole');
goog.require('goog.debug.Logger');
goog.require('goog.debug.LogManager');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.Uri');
goog.require('cw.eventual');
goog.require('cw.string');
goog.require('cw.net.Stream');
goog.require('cw.net.IMinervaProtocol');
goog.require('cw.net.demo.getEndpoint');
goog.require('cw.net.demo.makeCredentialsData');
goog.require('cw.repr');
goog.require('cw.string');
</script>

<script>
// Insert an image that takes a while to load, to make sure our
// WebKit spinner-killer works.  Do this after loading the resources
// above, to prevent an HTTP pipeline stall (happens in Opera, at least).
document.write('<img src="/wait_resource/?wait=4&zx=' +
	Math.random() + '" width=1 height=1>');
</script>

<script>
goog.debug.LogManager.getRoot().setLevel(goog.debug.Logger.Level.ALL);

var logDiv = document.getElementById('log');
var divConsole = new goog.debug.DivConsole(logDiv);
divConsole.setCapturing(true);

chatapp.logger = goog.debug.Logger.getLogger('chatapp.logger');
chatapp.logger.info('Logger works.');


window.onerror = function(msg, url, lineNumber) {
	chatapp.logger.severe('window.onerror: message: ' + cw.repr.repr(msg) +
		'\nURL: ' + url + '\nLine Number: ' + lineNumber)
};


function byId(o) {
	return document.getElementById(o);
}

/**
 * @implements {cw.net.IMinervaProtocol}
 * @constructor
 */
chatapp.ChatProtocol = function() {

};

chatapp.ChatProtocol.prototype.streamStarted = function(stream) {
	this.stream_ = stream;
	chatapp.logger.info('streamStarted');
	this.stream_.sendStrings(['begin_chat']);
};

chatapp.ChatProtocol.prototype.streamReset = function(reasonString, applicationLevel) {
	chatapp.logger.info(
		'streamReset: reasonString=' + cw.repr.repr(reasonString) +
		', applicationLevel=' + applicationLevel);
};

chatapp.ChatProtocol.prototype.handleString_ = function(s) {
	function fail() {
		chatapp.logger.severe('Could not handle string: ' + cw.repr.repr(s));
	}

	var splitted = cw.string.split(s, '|', 2);
	if(splitted.length != 3) {
		return fail();
	}
	var type = splitted[0];
	var uaId = splitted[1];
	var text = splitted[2];
	if(type != "TEXT") {
		return fail();
	}

	// TODO: add timestamp
	chatapp.logger.info(cw.string.format('<{0}> {1}', uaId, text));
};

chatapp.ChatProtocol.prototype.stringsReceived = function(strings) {
	for(var i=0; i < strings.length; i++) {
		var s = strings[i];
		this.handleString_(s);
	}
};

/**
 * @param {string} reason
 */
chatapp.ChatProtocol.prototype.reset = function(reason) {
	chatapp.logger.info('resetting with reason: ' + reason);
	this.stream_.reset(reason);
};

chatapp.ChatProtocol.prototype.sendText = function(text) {
	chatapp.logger.info('sendText: ' + text);
	this.stream_.sendStrings(["broadcast:" + text]);
};


/**
 * @type {?chatapp.ChatProtocol}
 */
chatapp.lastProto = null;


chatapp.callQueue = new cw.eventual.CallQueue(goog.global['window']);


chatapp.idleFired = function() {
	chatapp.resetStream("idle timeout fired");
	chatapp.lastProto = null;
};


chatapp.idleTimeout = null;


chatapp.activityDetected = function(ev) {
	if(chatapp.idleTimeout != null) {
		chatapp.callQueue.clock.clearTimeout(chatapp.idleTimeout);
	}

	// Only need a timeout if we have an active Stream
	if(chatapp.lastProto) {
		chatapp.idleTimeout = chatapp.callQueue.clock.setTimeout(
			chatapp.idleFired, 600 * 1000);
	}
};


/**
 * @type {!Array.<!goog.events.EventType>}
 */
chatapp.activityEvents = [
	goog.events.EventType.CLICK,
	goog.events.EventType.FOCUS,
	goog.events.EventType.KEYDOWN,
	goog.events.EventType.KEYPRESS];
chatapp.clickListen = goog.events.listen(
	goog.global, chatapp.activityEvents, chatapp.activityDetected, true);


chatapp.startStream = function() {
	chatapp.lastProto = new chatapp.ChatProtocol();
	chatapp.activityDetected();
	var endpointD = cw.net.demo.getEndpoint(chatapp.callQueue);
	endpointD.addCallback(function(endpoint) {
		var stream = new cw.net.Stream(
			chatapp.callQueue, chatapp.lastProto, endpoint, cw.net.demo.makeCredentialsData);
		stream.start();
	});
};


/**
 * @param {string} reason
 */
chatapp.resetStream = function(reason) {
	chatapp.lastProto.reset(reason);
};


chatapp.reconnectStream = function() {
	if(chatapp.lastProto) {
		chatapp.lastProto.reset('because user clicked reconnect button');
	}
	chatapp.startStream();
};


chatapp.sendText = function(text) {
	chatapp.lastProto.sendText(text);
};


chatapp.startStream();

</script>

</body>
</html>
