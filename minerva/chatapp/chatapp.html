<!doctype html>
<html>
<head>
	<meta http-equiv="charset" content="text/html; charset=utf-8">
	<title></title>
	<style>
		{{ getTestPageCSS() }}

		#controls tr td {
			padding: 0.5em 0 0.5em 0;
		}
	</style>
</head>
<body>

<div id="doc">
</div>

<table id="controls">
<tr>
	<td>Reconnect:</td>
	<td>
		<input type="submit" value="Reset" onclick="chatapp.resetStream();return false">
		<input type="submit" value="Reset and connect new stream" onclick="chatapp.reconnectStream();return false">
	</td>
</tr>
<tr>
<td>
	Send text:
</td>
<td>
	<input type="text" name="textinput" id="textinput">
	<input type="submit" value="Send" onclick="chatapp.sendText(byId('textinput').value);return false">
</td>
</tr>
</table>

<!--
Think about this: if in the future we have cross-tab sharing
working with named-window grabbing and SharedWorker, do we
really want to dump two iframes and two DNS requests on the user
for each page they load?  That seems kind of bad.  We should try
to connect to other tabs first, then create an iframe.

To combine the best of both worlds: leave a cookie that indicates
whether there is probably an already-connected Stream in a tab.
If no such cookie, write out the iframes immediately.
-->
<script>
	// Use just one preamble <script> to reduce page load time.

	window.CSRF_TOKEN = {{ dumps(token) }};
	document.domain = {{ dumps(domain) }};
	var __XDRFrame_loaded = function(id) {
		__XDRFrame_loaded.done.push(id);
	};
	__XDRFrame_loaded.done = [];
	// We expect location.port to be an empty string if no :port is in
	// the URL.  If there is an explicit port, we need to load the iframe
	// with that port, even if it's the default port (80 or 443), because
	// a mismatch of "explicit port" and "implicit port" may prevent
	// cross-subdomain interaction from working in some browsers.
	__XDRFrame_loaded.portString = location.port ? ':' + location.port : "";
	document.write(
		'<iframe width=16 height=16 src="//{{ sub1 }}.{{ domain }}' +
			__XDRFrame_loaded.portString + '/xdrframe/?id=1"></iframe>' +
		'<iframe width=16 height=16 src="//{{ sub2 }}.{{ domain }}' +
			__XDRFrame_loaded.portString + '/xdrframe/?id=2"></iframe>');
</script>

<div id="FlashConnectorSwf"></div>

<div id="log"></div>

<script src="/JSPATH/closure/goog/base.js"></script>
<script src="/JSPATH/nongoog_deps.js"></script>
<script>
goog.provide('chatapp');

goog.require('cw.autoTitle');
goog.require('goog.debug.DivConsole');
goog.require('goog.debug.Logger');
goog.require('goog.dom');
goog.require('goog.async.Deferred');
goog.require('goog.ui.media.FlashObject');
goog.require('cw.loadflash');
goog.require('goog.Uri');
goog.require('cw.eventual');
goog.require('cw.string');
goog.require('cw.net.Stream');
goog.require('cw.net.SocketEndpoint');
goog.require('cw.net.HttpEndpoint');
goog.require('cw.net.IMinervaProtocol');
goog.require('cw.net.FlashSocketTracker');
goog.require('cw.whoami');
goog.require('cw.repr');
goog.require('cw.string');
</script>

<script>
var logDiv = document.getElementById('log');
var divConsole = new goog.debug.DivConsole(logDiv);
divConsole.setCapturing(true);

chatapp.logger = goog.debug.Logger.getLogger('chatapp.logger');
chatapp.logger.setLevel(goog.debug.Logger.Level.ALL);

chatapp.logger.info('Logger works.');


window.onerror = function(msg, url, lineNumber) {
	chatapp.logger.severe('window.onerror: message: ' + cw.repr.repr(msg) +
		'\nURL: ' + url + '\nLine Number: ' + lineNumber)
};


function byId(o) {
	return document.getElementById(o);
}

/**
 * @implements {cw.net.IMinervaProtocol}
 * @constructor
 */
chatapp.ChatProtocol = function() {

};

chatapp.ChatProtocol.prototype.streamStarted = function(stream) {
	this.stream_ = stream;
	chatapp.logger.info('streamStarted');
	this.stream_.sendStrings(['begin_chat']);
};

chatapp.ChatProtocol.prototype.streamReset = function(reasonString, applicationLevel) {
	chatapp.logger.info('streamReset: ' + reasonString + ', ' + applicationLevel);
};

chatapp.ChatProtocol.prototype.handleString_ = function(s) {
	function fail() {
		chatapp.logger.severe('Could not handle string: ' + cw.repr.repr(s));
	}

	var splitted = cw.string.split(s, '|', 2);
	if(splitted.length != 3) {
		return fail();
	}
	var type = splitted[0];
	var uaId = splitted[1];
	var text = splitted[2];
	if(type != "TEXT") {
		return fail();
	}

	// TODO: add timestamp
	chatapp.logger.info(cw.string.format('<{0}> {1}', uaId, text));
};

chatapp.ChatProtocol.prototype.stringsReceived = function(strings) {
	for(var i=0; i < strings.length; i++) {
		var s = strings[i];
		this.handleString_(s);
	}
};

chatapp.ChatProtocol.prototype.reset = function() {
	this.stream_.reset("because user clicked button");
};

chatapp.ChatProtocol.prototype.sendText = function(text) {
	chatapp.logger.info('sendText: ' + text);
	this.stream_.sendStrings(["broadcast:" + text]);
};


chatapp.makeCredentialsData = function() {
	// Already base64-url-safe encoded
	var uaId = cw.whoami.getUaId();
	return uaId + '|' + window.CSRF_TOKEN;
};


/**
 * @type {?chatapp.ChatProtocol}
 */
chatapp.lastProto = null;


/**
 * @private
 * @return {!goog.async.Deferred} Deferred that fires with an object or embed
 *	 element.
 */
chatapp.loadFlashConnector_ = function() {
	flashObject = new goog.ui.media.FlashObject('/compiled_client/FlashConnector.swf');
	flashObject.setBackgroundColor("#777777");
	flashObject.setSize(300, 30);
	var renderInto = goog.dom.getElement("FlashConnectorSwf");
	var d = cw.loadflash.loadFlashObjectWithTimeout(
		chatapp.callQueue.clock, flashObject, '9', renderInto, 8000);
	return d;
};


/**
 * @return {!goog.async.Deferred} Deferred that fires with a {!cw.net.Endpoint}
 */
chatapp.getEndpoint = function() {
	var url = new goog.Uri(document.location);
	var queryData = url.getQueryData();
	var mode = queryData.get('mode');
	if(mode == 'http') {
		var endpoint = new cw.net.HttpEndpoint('/httpface/', '/httpface/');
		return goog.async.Deferred.succeed(endpoint);
	} else {
		var host = url.getDomain();
		var port = 843;
		var d = chatapp.loadFlashConnector_();
		d.addCallback(function(bridge) {
			var tracker = new cw.net.FlashSocketTracker(chatapp.callQueue, bridge);
			var endpoint = new cw.net.SocketEndpoint(host, port, tracker);
			return endpoint;
		});
		return d;
	}
};


chatapp.callQueue = new cw.eventual.CallQueue(goog.global['window']);


chatapp.startStream = function() {
	chatapp.lastProto = new chatapp.ChatProtocol();
	var endpointD = chatapp.getEndpoint();
	endpointD.addCallback(function(endpoint) {
		var stream = new cw.net.Stream(
			chatapp.callQueue, chatapp.lastProto, endpoint, chatapp.makeCredentialsData);
		stream.start();
	});
};


chatapp.resetStream = function() {
	chatapp.lastProto.reset();
};


chatapp.reconnectStream = function() {
	chatapp.lastProto.reset();
	chatapp.startStream();
};


chatapp.sendText = function(text) {
	chatapp.lastProto.sendText(text);
};


chatapp.startStream();

</script>

</body>
</html>
