<!doctype html>
<html>
<head>
	<meta http-equiv="charset" content="text/html; charset=utf-8">
	<title></title>
	<style>
		{{ getTestPageCSS() }}

		#controls tr td {
			padding: 0.5em 0 0.5em 0;
		}
	</style>
</head>
<body>

<div id="info">
<p>
This page supports options ?mode=http, ?mode=flash, ?useSub=0, ?useSub=1, ?httpStreaming=1
(which can be combined).  Note: when using subdomains, you'll see fewer log
messages because log messages in the iframes are not sent to this parent window.
When testing with Opera, open the Error Console, because window.onerror does
not work in Opera.  Do the same in Chrome, because not all errors are caught by
window.onerror (such as when calling a nonexistent method on an HTMLEmbedElement).
</p>

Do all of these when testing:
<ul>
<li>Test this page with ?mode=flash.</li>
<li>Test this page with ?mode=http&useSub=0.</li>
<li>Test this page with ?mode=http&useSub=1.</li>
<li>This server listens on both HTTP and HTTPS. Repeat above tests with both HTTP and HTTPS.</li>
<li>For mode=http&useSub=1 : Reload this page with F5.  Firefox 3+ has problems related to this.</li>
<li>For mode=http&useSub=1 : Arrive to this page via Back button from another page.  IE has problems related to this.</li>
<li>For mode=flash : Arrive to this page via Back button from another page.  Opera has problems related to this.</li>
<li>Load the page in a WebKit browser, make sure the spinner stops spinning after 4 seconds.</li>
<li>If the browser loads Flash out-of-process, kill the plugin container process
	and make sure Minerva keeps working (though Stream may reset).
	In Firefox, kill plugin-container.exe.  In Chrome, use shift-Esc and end the Flash process.</li>
</ul>

If you want to see what's in the send queue, enter this into your URL bar:
<code>javascript:alert(cw.repr.repr(chatapp.lastProto.stream_.queue_.items_.map_))</code>
</div>

<table id="controls">
<tr>
	<td>Reconnect:</td>
	<td>
		<input type="submit" value="Reset" onclick="chatapp.resetStream('because user clicked button');return false">
		<input type="submit" value="Reset and connect new stream" onclick="chatapp.reconnectStream();return false">
	</td>
</tr>
<tr>
<td>
	Send text:
</td>
<td>
	<input type="text" name="textinput" id="textinput">
	<input type="submit" value="Send" onclick="chatapp.sendText(byId('textinput').value);return false">
</td>
</tr>
</table>

<!--
Think about this: if in the future we have cross-tab sharing
working with named-window grabbing and SharedWorker, do we
really want to dump two iframes and two DNS requests on the user
for each page they load?  That seems kind of bad.  We should try
to connect to other tabs first, then create an iframe.

To combine the best of both worlds: leave a cookie that indicates
whether there is probably an already-connected Stream in a tab.
If no such cookie, write out the iframes immediately.
-->
<script>
// Don't define variables on "window" to avoid possible IE stack limit of 12
// when calling through window.
CSRF_TOKEN = {{ dumps(token) }};
__XDRSetup = {
	dev: true,
	domain: {{ dumps(domain) }},
	sub1: {{ dumps(sub1) }},
	sub2: {{ dumps(sub2) }}
};
</script>

<div id="minerva-xdrframes"></div>
<script src="/JSPATH/cw/net/bootstrap_XDRSetup.js"></script>

<div id="FlashConnectorSwf"></div>
<div id="log"></div>

<script>CLOSURE_NO_DEPS = true;</script>
<script src="/JSPATH/closure/goog/base.js"></script>
<script src="/JSPATH/all_deps.js"></script>
<script>
goog.provide('chatapp');

goog.require('cw.autoTitle');
goog.require('goog.debug.DivConsole');
goog.require('goog.debug.Logger');
goog.require('goog.debug.LogManager');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.Uri');
goog.require('cw.eventual');
goog.require('cw.string');
goog.require('cw.net.Stream');
goog.require('cw.net.IMinervaProtocol');
goog.require('cw.net.HttpStreamingMode');
goog.require('cw.net.demo.getEndpoint');
goog.require('cw.net.demo.makeCredentialsData');
goog.require('cw.repr');
goog.require('cw.string');
</script>

<script>
// Insert an image that takes a while to load, to make sure our
// WebKit spinner-killer works.  Load the image from another subdomain to
// prevent an HTTP pipeline stall.  Note that this doesn't actually help
// in any known browser.  Opera for some reason waits for this image
// to load, but not because of pipelining.
document.write('<img src="//wait-' + __XDRSetup.sub1 + __XDRSetup.suffix +
	'wait_resource/?wait=4&zx=' + Math.random() + '" width=16 height=16 border=2>');
</script>

<script>
goog.debug.LogManager.getRoot().setLevel(goog.debug.Logger.Level.ALL);

var logDiv = document.getElementById('log');
var divConsole = new goog.debug.DivConsole(logDiv);
divConsole.setCapturing(true);

chatapp.logger = goog.debug.Logger.getLogger('chatapp.logger');
chatapp.logger.info('Logger works.');


window.onerror = function(msg, url, lineNumber) {
	chatapp.logger.severe('window.onerror: message: ' + cw.repr.repr(msg) +
		'\nURL: ' + url + '\nLine Number: ' + lineNumber)
};


function byId(o) {
	return document.getElementById(o);
}

/**
 * @implements {cw.net.IMinervaProtocol}
 * @constructor
 */
chatapp.ChatProtocol = function() {

};

chatapp.ChatProtocol.prototype.streamStarted = function(stream) {
	this.stream_ = stream;
	chatapp.logger.info('streamStarted');
	this.stream_.sendStrings(['begin_chat']);
};

chatapp.ChatProtocol.prototype.streamReset = function(reasonString, applicationLevel) {
	chatapp.logger.info(
		'streamReset: reasonString=' + cw.repr.repr(reasonString) +
		', applicationLevel=' + applicationLevel);
	chatapp.lastProto = null;
};

chatapp.ChatProtocol.prototype.handleString_ = function(s) {
	function fail() {
		chatapp.logger.severe('Could not handle string: ' + cw.repr.repr(s));
	}

	var splitted = cw.string.split(s, '|', 2);
	if(splitted.length != 3) {
		return fail();
	}
	var type = splitted[0];
	var uaId = splitted[1];
	var text = splitted[2];
	if(type != "TEXT") {
		return fail();
	}

	// TODO: add timestamp
	chatapp.logger.info(cw.string.format('<{0}> {1}', uaId, text));
};

chatapp.ChatProtocol.prototype.stringsReceived = function(strings) {
	for(var i=0; i < strings.length; i++) {
		var s = strings[i];
		this.handleString_(s);
	}
};

/**
 * @param {string} reason
 */
chatapp.ChatProtocol.prototype.reset = function(reason) {
	chatapp.logger.info('resetting with reason: ' + reason);
	this.stream_.reset(reason);
};

chatapp.ChatProtocol.prototype.sendText = function(text) {
	chatapp.logger.info('sendText: ' + text);
	this.stream_.sendStrings(["broadcast:" + text]);
};


/**
 * @type {?chatapp.ChatProtocol}
 */
chatapp.lastProto = null;


chatapp.callQueue = new cw.eventual.CallQueue(goog.global['window']);


chatapp.idleFired = function() {
	if(!chatapp.lastProto) {
		return;
	}
	chatapp.resetStream("idle timeout fired");
	chatapp.lastProto = null;
};


chatapp.idleTimeout = null;


chatapp.activityDetected = function(ev) {
	if(chatapp.idleTimeout != null) {
		chatapp.callQueue.clock.clearTimeout(chatapp.idleTimeout);
	}

	// Only need a timeout if we have an active Stream
	if(chatapp.lastProto) {
		chatapp.idleTimeout = chatapp.callQueue.clock.setTimeout(
			chatapp.idleFired, 600 * 1000);
	}
};


/**
 * @type {!Array.<!goog.events.EventType>}
 */
chatapp.activityEvents = [
	goog.events.EventType.CLICK,
	goog.events.EventType.FOCUS,
	goog.events.EventType.KEYDOWN,
	goog.events.EventType.KEYPRESS];
chatapp.clickListen = goog.events.listen(
	goog.global, chatapp.activityEvents, chatapp.activityDetected, true);


chatapp.startStream = function() {
	var streamPolicy = new cw.net.demo.DemoStreamPolicy(
		cw.net.HttpStreamingMode.NO_STREAMING);
	chatapp.lastProto = new chatapp.ChatProtocol();
	chatapp.activityDetected();
	var endpointD = cw.net.demo.getEndpointByQueryArgs(chatapp.callQueue);
	endpointD.addCallback(function(endpoint) {
		var stream = new cw.net.Stream(
			chatapp.callQueue, chatapp.lastProto, endpoint, streamPolicy);
		stream.start();
	});
};


/**
 * @param {string} reason
 */
chatapp.resetStream = function(reason) {
	chatapp.lastProto.reset(reason);
};


chatapp.reconnectStream = function() {
	if(chatapp.lastProto) {
		chatapp.lastProto.reset('because user clicked reconnect button');
	}
	chatapp.startStream();
};


chatapp.sendText = function(text) {
	chatapp.lastProto.sendText(text);
};


chatapp.startStream();

</script>

</body>
</html>
