<!doctype html>
<html>
<head>
	<meta http-equiv="charset" content="text/html; charset=utf-8">
	<title></title>
	<style>
		{{ getTestPageCSS() }}

		#controls tr td {
			padding: 0.5em 0 0.5em 0;
		}
	</style>
</head>
<body>

<div id="info">
<p>
This page supports options ?mode=http, ?mode=flash, ?useSub=0, ?useSub=1
(which can be combined).  Note: when using subdomains, you'll see fewer log
messages because log messages in the iframes are not sent to this parent window.
</p>

Do all of these when testing:
<ul>
<li>Test this page with ?mode=flash.</li>
<li>Test this page with ?mode=http&useSub=0.</li>
<li>Test this page with ?mode=http&useSub=1.</li>
<li>This server listens on both HTTP and HTTPS. Repeat above tests with both HTTP and HTTPS.</li>
<li>For mode=http&useSub=1 : Hit F5 in Firefox a few times, make sure it still works.</li>
<li>Load the page in a WebKit browser, make sure the spinner stops spinning after 4 seconds.</li>
</ul>
</div>

<table id="controls">
<tr>
	<td>Reconnect:</td>
	<td>
		<input type="submit" value="Reset" onclick="chatapp.resetStream('because user clicked button');return false">
		<input type="submit" value="Reset and connect new stream" onclick="chatapp.reconnectStream();return false">
	</td>
</tr>
<tr>
<td>
	Send text:
</td>
<td>
	<input type="text" name="textinput" id="textinput">
	<input type="submit" value="Send" onclick="chatapp.sendText(byId('textinput').value);return false">
</td>
</tr>
</table>

<!--
Think about this: if in the future we have cross-tab sharing
working with named-window grabbing and SharedWorker, do we
really want to dump two iframes and two DNS requests on the user
for each page they load?  That seems kind of bad.  We should try
to connect to other tabs first, then create an iframe.

To combine the best of both worlds: leave a cookie that indicates
whether there is probably an already-connected Stream in a tab.
If no such cookie, write out the iframes immediately.
-->
<script>
	// Insert an image that takes a while to load, to make sure our
	// WebKit spinner-killer works.
	document.write('<img src="/wait_resource/?wait=4&zx=' +
		Math.random() + '" width=1 height=1>');

	// Use just one preamble <script> to reduce page load time.

	window.CSRF_TOKEN = {{ dumps(token) }};
	document.domain = {{ dumps(domain) }};
	var __XDRFrame_loaded = function(id) {
		__XDRFrame_loaded.done.push(id);
	};
	__XDRFrame_loaded.done = [];
	// We expect location.port to be an empty string if no :port is in
	// the URL.  If there is an explicit port, we need to load the iframe
	// with that port, even if it's the default port (80 or 443), because
	// a mismatch of "explicit port" and "implicit port" may prevent
	// cross-subdomain interaction from working in some browsers.
	__XDRFrame_loaded.portString = location.port ? ':' + location.port : "";
	__XDRFrame_loaded.url1 = location.protocol + '//{{ sub1 }}.{{ domain }}' +
		__XDRFrame_loaded.portString + '/';
	__XDRFrame_loaded.url2 = location.protocol + '//{{ sub2 }}.{{ domain }}' +
		__XDRFrame_loaded.portString + '/';
	document.write(
		'<iframe width=16 height=16 src="' + __XDRFrame_loaded.url1 +
			'xdrframe/?id=1" id="xdrframe-1"></iframe>' +
		'<iframe width=16 height=16 src="' + __XDRFrame_loaded.url2 +
			'xdrframe/?id=2" id="xdrframe-2"></iframe>');
</script>

<div id="FlashConnectorSwf"></div>

<div id="log"></div>

<script src="/JSPATH/closure/goog/base.js"></script>
<script src="/JSPATH/nongoog_deps.js"></script>
<script>
goog.provide('chatapp');

goog.require('cw.autoTitle');
goog.require('goog.debug.DivConsole');
goog.require('goog.debug.Logger');
goog.require('goog.debug.LogManager');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.Uri');
goog.require('cw.eventual');
goog.require('cw.string');
goog.require('cw.net.Stream');
goog.require('cw.net.IMinervaProtocol');
goog.require('cw.net.demo.getEndpoint');
goog.require('cw.net.demo.makeCredentialsData');
goog.require('cw.repr');
goog.require('cw.string');
</script>

<script>
goog.debug.LogManager.getRoot().setLevel(goog.debug.Logger.Level.ALL);

var logDiv = document.getElementById('log');
var divConsole = new goog.debug.DivConsole(logDiv);
divConsole.setCapturing(true);

chatapp.logger = goog.debug.Logger.getLogger('chatapp.logger');
chatapp.logger.info('Logger works.');


window.onerror = function(msg, url, lineNumber) {
	chatapp.logger.severe('window.onerror: message: ' + cw.repr.repr(msg) +
		'\nURL: ' + url + '\nLine Number: ' + lineNumber)
};


function byId(o) {
	return document.getElementById(o);
}

/**
 * @implements {cw.net.IMinervaProtocol}
 * @constructor
 */
chatapp.ChatProtocol = function() {

};

chatapp.ChatProtocol.prototype.streamStarted = function(stream) {
	this.stream_ = stream;
	chatapp.logger.info('streamStarted');
	this.stream_.sendStrings(['begin_chat']);
};

chatapp.ChatProtocol.prototype.streamReset = function(reasonString, applicationLevel) {
	chatapp.logger.info(
		'streamReset: reasonString=' + cw.repr.repr(reasonString) +
		', applicationLevel=' + applicationLevel);
};

chatapp.ChatProtocol.prototype.handleString_ = function(s) {
	function fail() {
		chatapp.logger.severe('Could not handle string: ' + cw.repr.repr(s));
	}

	var splitted = cw.string.split(s, '|', 2);
	if(splitted.length != 3) {
		return fail();
	}
	var type = splitted[0];
	var uaId = splitted[1];
	var text = splitted[2];
	if(type != "TEXT") {
		return fail();
	}

	// TODO: add timestamp
	chatapp.logger.info(cw.string.format('<{0}> {1}', uaId, text));
};

chatapp.ChatProtocol.prototype.stringsReceived = function(strings) {
	for(var i=0; i < strings.length; i++) {
		var s = strings[i];
		this.handleString_(s);
	}
};

/**
 * @param {string} reason
 */
chatapp.ChatProtocol.prototype.reset = function(reason) {
	chatapp.logger.info('resetting with reason: ' + reason);
	this.stream_.reset(reason);
};

chatapp.ChatProtocol.prototype.sendText = function(text) {
	chatapp.logger.info('sendText: ' + text);
	this.stream_.sendStrings(["broadcast:" + text]);
};


/**
 * @type {?chatapp.ChatProtocol}
 */
chatapp.lastProto = null;


chatapp.callQueue = new cw.eventual.CallQueue(goog.global['window']);


chatapp.idleFired = function() {
	chatapp.resetStream("idle timeout fired");
	chatapp.lastProto = null;
};


chatapp.idleTimeout = null;


chatapp.activityDetected = function(ev) {
	if(chatapp.idleTimeout != null) {
		chatapp.callQueue.clock.clearTimeout(chatapp.idleTimeout);
	}

	// Only need a timeout if we have an active Stream
	if(chatapp.lastProto) {
		chatapp.idleTimeout = chatapp.callQueue.clock.setTimeout(
			chatapp.idleFired, 600 * 1000);
	}
};


/**
 * @type {!Array.<!goog.events.EventType>}
 */
chatapp.activityEvents = [
	goog.events.EventType.CLICK,
	goog.events.EventType.FOCUS,
	goog.events.EventType.KEYDOWN,
	goog.events.EventType.KEYPRESS];
chatapp.clickListen = goog.events.listen(
	goog.global, chatapp.activityEvents, chatapp.activityDetected, true);


chatapp.startStream = function() {
	chatapp.lastProto = new chatapp.ChatProtocol();
	chatapp.activityDetected();
	var endpointD = cw.net.demo.getEndpoint(chatapp.callQueue);
	endpointD.addCallback(function(endpoint) {
		var stream = new cw.net.Stream(
			chatapp.callQueue, chatapp.lastProto, endpoint, cw.net.demo.makeCredentialsData);
		stream.start();
	});
};


/**
 * @param {string} reason
 */
chatapp.resetStream = function(reason) {
	chatapp.lastProto.reset(reason);
};


chatapp.reconnectStream = function() {
	if(chatapp.lastProto) {
		chatapp.lastProto.reset('because user clicked reconnect button');
	}
	chatapp.startStream();
};


chatapp.sendText = function(text) {
	chatapp.lastProto.sendText(text);
};


chatapp.startStream();

</script>

</body>
</html>
