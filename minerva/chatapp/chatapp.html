<!doctype html>
<html>
<head>
	<meta http-equiv="charset" content="text/html; charset=utf-8">
	<title></title>
	<link rel="stylesheet" href="/@testres_Coreweb/test_page.css" type="text/css">
	<style>
		#controls tr td {
			padding: 0.5em 0 0.5em 0;
		}
	</style>
</head>
<body>
<script>
// In minerva_site, user specifies this with the command-line --domain option
__demo_shared_domain = {{ htmldumps(domain) }};
</script>

<div id="info">
<p>
This test page implements a rudimentary chat, but it is mostly useful for inspecting the
Minerva protocol traffic.  Type text in the "Send text" box below and click "Send".  Observe
the traffic when this happens, or observe the traffic caused by another user sending a
message.
</p>

<p>
This page supports options ?mode=http, ?mode=flash, ?useSub=0, ?useSub=1, ?httpStreaming=1
(which can be combined).  Note: when using subdomains, you'll see fewer log
messages because log messages in the iframes are not sent to this parent window.
When testing with Opera, open the Error Console, because window.onerror does
not work in Opera.  Do the same in Chrome, because not all errors are caught by
window.onerror (such as when calling a nonexistent method on an HTMLEmbedElement).
</p>

Do all of these when testing:
<ul>
<li>Test this page with ?mode=flash.</li>
<li>Test this page with ?mode=http&useSub=0.</li>
<li>Test this page with ?mode=http&useSub=1.</li>
<li>This server listens on both HTTP and HTTPS. Repeat above tests with both HTTP and HTTPS.</li>
<li>For mode=http&useSub=1 : Reload this page with F5.  Firefox 3+ has problems related to this.</li>
<li>For mode=http&useSub=1 : Arrive to this page via Back button from another page.  IE has problems related to this.</li>
<li>For mode=flash : Arrive to this page via Back button from another page.  Opera has problems related to this.</li>
<li>Load the page in a WebKit browser, make sure the spinner stops spinning after 4 seconds.</li>
<li>If the browser loads Flash out-of-process, kill the plugin container process
	and make sure Minerva keeps working (though Stream may reset).
	In Firefox, kill plugin-container.exe.  In Chrome, use shift-Esc and end the Flash process.</li>
</ul>

If you want to see what's in the send queue, enter this into your URL bar:
<code>javascript:alert(cw.repr.repr(chatapp.lastProto.stream_.queue_.items_.map_))</code>
</div>

<table id="controls">
<tr>
	<td>Reconnect:</td>
	<td>
		<input type="submit" value="Reset" onclick="chatapp.resetStream('because user clicked button');return false">
		<input type="submit" value="Reset and connect new stream" onclick="chatapp.reconnectStream();return false">
	</td>
</tr>
<tr>
<td>
	Send text:
</td>
<td>
	<input type="text" name="textinput" id="textinput">
	<input type="submit" value="Send" onclick="chatapp.sendText(byId('textinput').value);return false">
</td>
</tr>
</table>
<div id="minerva-xdrframes"></div>
<div id="FlashConnectorSwf"></div>
<div id="log"></div>

<script src="/closure-library/closure/goog/base.js"></script>
<script src="/js_coreweb/deps.js"></script>
<script src="/js_minerva/deps.js"></script>
<script>
goog.provide('chatapp');

goog.require('cw.autoTitle');
goog.require('goog.debug.DivConsole');
goog.require('goog.debug.Logger');
goog.require('goog.debug.LogManager');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.Uri');
goog.require('cw.eventual');
goog.require('cw.string');
goog.require('cw.net.Stream');
goog.require('cw.net.IMinervaProtocol');
goog.require('cw.net.HttpStreamingMode');
goog.require('cw.net.demo.getEndpointByQueryArgs');
goog.require('cw.repr');
goog.require('cw.string');
</script>

<script>
// Insert an image that takes a while to load, to make sure our
// WebKit spinner-killer works.  Load the image from another subdomain to
// prevent an HTTP pipeline stall.  Note that this doesn't actually help
// in any known browser.  Opera for some reason waits for this image
// to load, but not because of pipelining.

//if(__XDRSetup['use_subdomains']) {
//	document.write('<img src="//wait-' + __XDRSetup['host1'] +
//		'/wait_resource/?wait=4&zx=' + Math.random() + '" width=16 height=16 border=2>');
//} else {
//	document.write('<img src="/wait_resource/?wait=4&zx=' + Math.random() +
//		'" width=16 height=16 border=2>');
//}
</script>

<script>
goog.debug.LogManager.getRoot().setLevel(goog.debug.Logger.Level.ALL);

var logDiv = document.getElementById('log');
var divConsole = new goog.debug.DivConsole(logDiv);
divConsole.setCapturing(true);

chatapp.logger = goog.debug.Logger.getLogger('chatapp.logger');
chatapp.logger.info('Logger works.');


window.onerror = function(msg, url, lineNumber) {
	chatapp.logger.severe('window.onerror: message: ' + cw.repr.repr(msg) +
		'\nURL: ' + url + '\nLine Number: ' + lineNumber)
};


function byId(o) {
	return document.getElementById(o);
}

/**
 * @implements {cw.net.IMinervaProtocol}
 * @constructor
 */
chatapp.ChatProtocol = function() {

};

chatapp.ChatProtocol.prototype.setStream = function(stream) {
	this.stream_ = stream;
};

chatapp.ChatProtocol.prototype.sendInitialStrings = function() {
	this.stream_.sendStrings(['begin_chat']);
};

chatapp.ChatProtocol.prototype.streamReset = function(reasonString, applicationLevel) {
	chatapp.logger.info(
		'streamReset: reasonString=' + cw.repr.repr(reasonString) +
		', applicationLevel=' + applicationLevel);
	chatapp.lastProto = null;
};

chatapp.ChatProtocol.prototype.handleString_ = function(s) {
	function fail() {
		chatapp.logger.severe('Could not handle string: ' + cw.repr.repr(s));
	}

	var splitted = cw.string.split(s, '|', 2);
	if(splitted.length != 3) {
		return fail();
	}
	var type = splitted[0];
	var uaId = splitted[1];
	var text = splitted[2];
	if(type != "TEXT") {
		return fail();
	}

	// TODO: add timestamp
	chatapp.logger.info(cw.string.format('<{0}> {1}', uaId, text));
};

chatapp.ChatProtocol.prototype.stringReceived = function(s) {
	this.handleString_(s);
};

/**
 * @param {string} reason
 */
chatapp.ChatProtocol.prototype.reset = function(reason) {
	chatapp.logger.info('resetting with reason: ' + reason);
	this.stream_.reset(reason);
};

chatapp.ChatProtocol.prototype.sendText = function(text) {
	chatapp.logger.info('sendText: ' + text);
	this.stream_.sendStrings(["broadcast:" + text]);
};


/**
 * @type {?chatapp.ChatProtocol}
 */
chatapp.lastProto = null;


chatapp.callQueue = new cw.eventual.CallQueue(goog.global['window']);


chatapp.idleFired = function() {
	if(!chatapp.lastProto) {
		return;
	}
	chatapp.resetStream("idle timeout fired");
	chatapp.lastProto = null;
};


chatapp.idleTimeout = null;


chatapp.activityDetected = function(ev) {
	if(chatapp.idleTimeout != null) {
		chatapp.callQueue.clock.clearTimeout(chatapp.idleTimeout);
	}

	// Only need a timeout if we have an active Stream
	if(chatapp.lastProto) {
		chatapp.idleTimeout = chatapp.callQueue.clock.setTimeout(
			chatapp.idleFired, 600 * 1000);
	}
};


/**
 * @type {!Array.<!goog.events.EventType>}
 */
chatapp.activityEvents = [
	goog.events.EventType.CLICK,
	goog.events.EventType.FOCUS,
	goog.events.EventType.KEYDOWN,
	goog.events.EventType.KEYPRESS];
chatapp.clickListen = goog.events.listen(
	goog.global, chatapp.activityEvents, chatapp.activityDetected, true);


chatapp.startStream = function() {
	var streamPolicy = new cw.net.demo.DemoStreamPolicy(
		'minerva_site_uaid', 'minerva_site_uaid_secure');
	chatapp.lastProto = new chatapp.ChatProtocol();
	chatapp.activityDetected();

	// TODO: remove use of Deferred; getEndpointByQueryArgs should be
	// synchronous after we make a "nice Flash endpoint"
	var endpointD = cw.net.demo.getEndpointByQueryArgs(chatapp.callQueue);
	endpointD.addCallback(function(endpoint) {
		var stream = new cw.net.Stream(
			chatapp.callQueue, chatapp.lastProto, endpoint, streamPolicy);
		chatapp.lastProto.setStream(stream);
		chatapp.lastProto.sendInitialStrings();
		stream.start();
	});
	// endpointD.addErrback // TODO
};


/**
 * @param {string} reason
 */
chatapp.resetStream = function(reason) {
	chatapp.lastProto.reset(reason);
};


chatapp.reconnectStream = function() {
	if(chatapp.lastProto) {
		chatapp.lastProto.reset('because user clicked reconnect button');
	}
	chatapp.startStream();
};


chatapp.sendText = function(text) {
	chatapp.lastProto.sendText(text);
};


chatapp.startStream();

</script>

</body>
</html>
