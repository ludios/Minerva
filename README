Minerva
===

The goal of Minerva is to implement a framed and extra-reliable TCP on top of
various transports:
	HTTP requests and responses (optionally HTTPSed),
	TCP connections (for now, only unencrypted),
	WebSocket (optionally TLSed)


Why you might want Minerva:
	You need "Comet"/"HTTP push" to push data to users, similar to meebo/google talk/google finance

	You don't really need Comet, but want your "AJAX" to be reliable and secure:
		Minerva automatically retries requests if they fail
		Minerva can use WebSocket/Flash sockets, which can make it harder for
			your users to use Firebug/httpfox to determine what you are sending over the wire
		Minerva handles the CSRF stuff, as long as you set it up right

	You don't really need Comet, but your JavaScript application needs to make a bunch of requests,
	and you would rather write this as a "real" protocol instead of a bunch of AJAX requests.

	You are writing a desktop application that must run in extremely internet-hostile environments
	that do not even allow unmutilated socket connections over port 443.
		You can write a Minerva client that uses IE's proxy settings, or even controls a real
		IE window, to send and receive data.


Above, we said that Minerva is a "framed and extra-reliable TCP".
By framed, we mean that applications send and receive frames, not octets.
Why force applications to work with frames instead of octets? One might
object and say that applications need direct access to octets, but consider these points:

	Minerva's frame overhead is minimal: 4 extra bytes are needed to
	send an integer 0-9, or 6 extra bytes to send an ASCII letter.

	Even if you send just one byte over TCP, the TCP/IP overhead will be approximately 52 bytes
	(there is even more overhead when HTTP chunk lengths or TLS are involved).

	If it worked with octets, Minerva would need to encode and decode these octets
	using base64 or similar, because:

		Over HTTP transports, NULL cannot be sent to IE or Opera

		Minerva sometimes needs to send metadata over the transports that applications are using,
		to determine if a transport is stalled or being buffered by proxies.

	WebSocket natively uses frames, and NULLs cannot be sent over them (as of 2009-11).

	We want to avoid using JavaScript (especially IE's slow JScript) to parse frames.
	Instead we delegate this to the web browser's C++ code, or Flash's AVM2.
	We want to avoid using JavaScript (especially IE's slow JScript) to handle the UTF-8<->Unicode conversion.
	By requiring frames, it's an easy step to require Unicode frames, so Minerva can handle this
	instead of the application.



The frames contain semi-structured data (JSON). JSON is used as a building
block because:
	The IE htmlfile transport automatically parses JSON as it is dumped into the HTML page,
	because it is basically executing JavaScript. Which means we don't have to dump
	a string to the page first, and then send it through a decoder.

	(in theory) In IE, using AVM2 to encode/decode JSON might be faster than eval() or json2.js,
	so Minerva can do whatever is fastest instead of requiring the application to do its own thing.

	JSON requires encoding NULL (U+0000), which is good because we cannot send it over some transports.

	Everyone understands JSON, and it is well-supported in most languages.

	IE8, Chrome, Firefox, Safari, and Opera have native JSON encoders and decoders.

	No obvious memory-exhaustion problems. Cclients cannot send "x"*1000000 or
	some nonsense and have it fill up memory)



Problems with JSON:
	No support for dates, or sets

	Allows unlimited nesting, so you must worry about stack exhaustion.

	Because JSON allows as many keys as you want, you have to deal with possible
	CPU-resource DoS caused by clients exploiting predictable hashing algorithms

	The overhead of quoting every key in {"key": value} even when key is not a
	reserved word in JavaScript is annoying
