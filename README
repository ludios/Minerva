Minerva
===

The goal of Minerva is to implement a framed and extra-reliable TCP on top of
various transports:
	HTTP requests and responses (optionally HTTPSed),
	TCP connections (for now, only unencrypted),
	WebSocket (optionally TLSed)


Why you might want Minerva:
	You need "Comet"/"HTTP push" to push data to users, similar to meebo/google talk/google finance

	You don't really need Comet, but want your "AJAX" to be reliable and secure:
		Minerva automatically retries requests if they fail
		Minerva can use WebSocket/Flash sockets, which make it harder for
			your users to figure out what you sent over the wire with Firebug/HttpFox.
		Minerva handles the CSRF stuff, as long as you set it up right

	You don't really need Comet, but your JavaScript application needs to make a bunch of requests,
	and you would rather write this as a "real" protocol instead of a bunch of AJAX requests.

	You are writing a desktop application that needs a "real" protocol, and it must run in
	internet-hostile environments that do not even allow unmutilated socket connections over port 443.
		You can write a Minerva client that uses IE's proxy settings, or even controls a real
		IE window, to send and receive data.


Terminology:
	stream - the stateful object that protocols use to send and receive data. This is sort
		of like a TCP connection, but better in most ways.
	transport - an HTTP request/response, or socket, or WebSocket, that Minerva uses to send/receive frames.


Minerva will move heaven and earth to get your data across as efficiently and reliably as possible.
It uses streaming HTTP connections, unless it suspects a buffering proxy is in the way.
By "extra-reliable TCP" above, we meant that Minerva streams survive disconnects.
It also maintains the TCP properties of in-order and reliable data delivery.


Above, we said that Minerva is a "framed and extra-reliable TCP".
By framed, we mean that applications send and receive frames, not octets.
Why force applications to work with frames instead of octets? One might
object and say that applications need direct access to octets, but consider these points:

	Minerva's frame overhead is minimal: just 3 extra bytes for the smallest frames.

		This overhead is dwarfed by the per-packet TCP/IP overhead of ~52 bytes
		(there is even more overhead when HTTP chunk lengths or TLS are involved).

	If it worked with octets, Minerva would need to encode and decode these octets
	using base64 or similar, because:

		Over HTTP transports, NULL cannot be sent to IE or Opera.

		Minerva sometimes needs to send metadata over the transports that applications are using,
		to determine if a transport is stalled or being buffered by proxies.

	WebSocket uses frames natively, and NULLs cannot be sent over them (as of 2009-11).

	When possible, we want to avoid using JavaScript (especially IE's slow JScript) to parse frames.
	Instead we delegate this to the web browser's C++ code, or Flash's AVM2.
	
	We want to avoid using JavaScript (especially IE's slow JScript) to handle the UTF-8<->Unicode conversion.
	By requiring frames, it's an easy step to require Unicode frames, so Minerva can handle this
	instead of the application.



The frames contain semi-structured data (JSON). JSON is used as a building
block because:
	The IE htmlfile transport automatically parses JSON as it is dumped into the HTML page,
	because it is basically executing JavaScript. Which means we don't have to dump
	a string to the page first, and then send it through a decoder.

	(in theory) In IE, using AVM2 to encode/decode JSON might be faster than eval() or json2.js,
	so Minerva can do whatever is fastest instead of requiring the application to do its own thing.

	JSON requires encoding NULL (U+0000), which is good because we cannot send it over
	all transports anyway.

	IE8, Chrome, Firefox, Safari, and Opera have native JSON encoders and decoders.

	No obvious memory-exhaustion problems. Clients cannot send "x"*1000000 or
	some nonsense and have it fill up memory)

Problems with JSON:
	No support for dates, or sets

	Allows unlimited nesting, so you must worry about stack exhaustion.

	Because JSON allows as many keys as you want, servers have to deal with possible
	CPU-resource DoS caused by clients exploiting predictable hashing algorithms.

	The overhead of quoting every key in {"key": value} even when key is not a
	reserved word in JavaScript is annoying.



Other cool Minerva features:

	Minerva can respond to TCP pressure using Twisted's producer/consumer system.
	You can easily stream megabytes of frames to a client while using little memory
	on the server. Responding to TCP pressure is useful, because it will save the client
	from having to send application-level "back off" / "ok, resume" messages.
	See section ("producers/consumers") below.

	Minerva JavaScript client: When Minerva uses HTTP transports, it tries its best to use a maximum
	of two TCP connections. Minerva understands when browsers have to open new TCP connections.

	Minerva JavaScript client: To reduce TCP connection establishment latencies, the client will avoid
	aborting HTTP connections. Because of how HTTP works, aborting an HTTP connection
	from the client necessitates closing the TCP connection.

	(planned) Minerva JavaScript client: Minerva uses "request interleaving" to reduce the gap
	where no data can be sent server->client.



Minerva limitations:

	Runs on Python, which is really slow.

	Relies on subdomains + document.domain for cross-domain communication,
	which necessitates a wildcard SSL cert

		Future: use postMessage, and Google Closure's VBScript-based transport for IE

	Minerva server ignores the selectively-acknowledged boxes in the SACK frame
	(only the primary ACK number is used)

	Minerva server does not use gzip or any other compression to compress the boxes.
	If you want the client to receive compressed data, write your client-side logic to make
	HTTP requests when necessary. These HTTP requests will hopefully be gzip-compressed.

		Future: automatic switch to gzipped HTTP S2C if there is a large volume of data to transmit.
			Procedure:
				Server-side application queues big boxes, or many boxes
				Minerva decides it would be faster to send these over a gzipped transport, even with
					the client forced to take a round-trip hit.
				Minerva server convinces the client to open an HTTP S2C transport
				Minerva server remembers that it has a lot of data to send, so this transport gets gzip headers
					and gzipped data is sent over it.
				Because the client cannot read all of the data until the HTTP request is closed, Minerva
					closes the transport fairly quickly.
		Future: zlib compression when using Flash transport
		Future: for websocket/http transports, some kind of client-side decompression inside a Web Worker 



Producers/consumers:

	Like twisted's TCP transport and twisted.web Requests, Minerva supports producers/consumers.
	See http://twistedmatrix.com/projects/core/documentation/howto/producers.html
	for information about them.

	In Minerva, a producer can be attached to the Stream (generally the MinervaProtocol
	attaches itself). This poses some challenges to the implementation, because Minerva
	transports may frequently attach and detach from the Stream.

	In general, TCP pressure from the TCP transport of the primary
	transport directly affects the producer attached to Stream. Also, if the producer is a push
	producer and no Minerva transports are attached the Stream, the producer is paused. 



Producers/consumers, technical details:

	"type of producer" means pull or push.

	This is the object chain, "upstream" objects at top. Objects on adjacent lines
	usually know about each other.

	MinervaProtocol
	Stream
	*Transport
	(Twisted)

	Producer attachment goes downstream, pressure information goes upstream.

	When a client connects, (Twisted) causes *Transport creation,
	which causes Stream creation, which causes MinervaProtocol creation. This
	might not happen instantly, because *Transport must be authenticated first.
	At this time, there are no producers in the system.

	MinervaProtocol can at any time register or unregister a pull or push producer with Stream.

	Stream's goal is to attach the same type of producer with every S2C transport that attaches to it,
	even if the S2C transport isn't attached yet.

	Stream must also unregister producers from transports that are no longer primary transports.

	If type of producer is push, Stream must also call pauseProducing on MinervaProtocol whenever
	there is no primary transport. It must also call resumeProducing when this situation ends.

	*Transport's job is simple, it just registers itself as the correct type of producer with Twisted.
	One edge case: it must remember if Twisted paused it, and if so, pauseProducing newly-attached push producers.

	During normal operation for a registered PULL producer, these conditions result in
	resumeProducing calls on MinervaProtocol:
		(Twisted) - [resume] when it wants more data to send

	During normal operation for a registered PUSH producer, these conditions result in
	pauseProducing or resumeProducing calls on MinervaProtocol:
		(Twisted) - [resume] when it wants more data to send
		(Twisted) - [pause] when it has enough data
		*Transport - [pause] if it was paused earlier by (Twisted)
		Stream - [pause] when there are no primary transports
		Stream - If paused, [resume] when a primary transport appears
