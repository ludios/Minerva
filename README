Minerva
===

The goal of Minerva is to implement a framed and extra-reliable TCP on top of
various transports:
	HTTP requests and responses (optionally HTTPSed),
	TCP connections (for now, only unencrypted),
	WebSocket (optionally TLSed)


Why you might want Minerva:
	You need "Comet"/"HTTP push" to push data to users, similar to meebo/google talk/google finance

	You don't really need Comet, but want your "AJAX" to be reliable and secure:
		Minerva automatically retries requests if they fail
		Minerva can use WebSocket/Flash sockets, which make it harder for
			your users to figure out what you sent over the wire with Firebug/HttpFox.
		Minerva handles the CSRF stuff, as long as you set it up right

	You don't really need Comet, but your JavaScript application needs to make a bunch of requests,
	and you would rather write this as a "real" protocol instead of a bunch of AJAX requests.

	You are writing a desktop application that needs a "real" protocol, and it must run in
	internet-hostile environments that do not even allow unmutilated socket connections over port 443.
		You can write a Minerva client that uses IE's proxy settings, or even controls a real
		IE window, to send and receive data.


Terminology:
	stream - the stateful object that protocols use to send and receive data. This is sort
		of like a TCP connection, but better in most ways.
	transport - an HTTP request/response, or socket, or WebSocket, that Minerva uses to send/receive frames.


Minerva will move heaven and earth to get your data across as efficiently and reliably as possible.
It uses streaming HTTP connections, unless it suspects a buffering proxy is in the way.
By "extra-reliable TCP" above, we meant that Minerva streams survive disconnects.
It also maintains the TCP properties of in-order and reliable data delivery.


Above, we said that Minerva is a "framed and extra-reliable TCP".
By framed, we mean that applications send and receive frames, not octets.
Why force applications to work with frames instead of octets? One might
object and say that applications need direct access to octets, but consider these points:

	Minerva's frame overhead is minimal: just 5-7 extra bytes for the smallest frames.

		This overhead is dwarfed by the per-packet TCP/IP overhead of ~52 bytes
		(there is even more overhead when HTTP chunk lengths or TLS are involved).

	If it worked with octets, Minerva would need to encode and decode these octets
	using base64 or similar, because:

		Over HTTP transports, NULL cannot be sent to IE or Opera.

		Minerva sometimes needs to send metadata over the transports that applications are using,
		to determine if a transport is stalled or being buffered by proxies.

	WebSocket uses frames natively, and NULLs cannot be sent over them (as of 2009-11).

	When possible, we want to avoid using JavaScript (especially IE's slow JScript) to parse frames.
	Instead we delegate this to the web browser's C++ code, or Flash's AVM2.
	
	We want to avoid using JavaScript (especially IE's slow JScript) to handle the UTF-8<->Unicode conversion.
	By requiring frames, it's an easy step to require Unicode frames, so Minerva can handle this
	instead of the application.



The frames contain semi-structured data (JSON). JSON is used as a building
block because:
	The IE htmlfile transport automatically parses JSON as it is dumped into the HTML page,
	because it is basically executing JavaScript. Which means we don't have to dump
	a string to the page first, and then send it through a decoder.

	(in theory) In IE, using AVM2 to encode/decode JSON might be faster than eval() or json2.js,
	so Minerva can do whatever is fastest instead of requiring the application to do its own thing.

	JSON requires encoding NULL (U+0000), which is good because we cannot send it over
	all transports anyway.

	IE8, Chrome, Firefox, Safari, and Opera have native JSON encoders and decoders.

	No obvious memory-exhaustion problems. Clients cannot send "x"*1000000 or
	some nonsense and have it fill up memory)

Problems with JSON:
	No support for dates, or sets

	Allows unlimited nesting, so you must worry about stack exhaustion.

	Because JSON allows as many keys as you want, servers have to deal with possible
	CPU-resource DoS caused by clients exploiting predictable hashing algorithms.

	The overhead of quoting every key in {"key": value} even when key is not a
	reserved word in JavaScript is annoying.



Other cool Minerva features:

	Minerva can respond to TCP pressure using Twisted's producer/consumer system.
	You can easily stream megabytes of frames to a client while using little memory
	on the server. Responding to TCP pressure is useful, because it will save the client
	from having to send application-level "back off" / "ok, resume" messages.
	See section ("producers/consumers") below.

	Minerva JavaScript client: When Minerva uses HTTP transports, it tries its best to use a maximum
	of two TCP connections. Minerva understands when browsers have to open new TCP connections.

	Minerva JavaScript client: To reduce TCP connection establishment latencies, the client will avoid
	aborting HTTP connections. Because of how HTTP works, aborting an HTTP connection
	from the client necessitates closing the TCP connection.

	(planned) Minerva JavaScript client: Minerva uses "request interleaving" to reduce the gap
	where no data can be sent server->client.



Minerva limitations:

	Runs on Python, which is really slow.

	Relies on subdomains + document.domain for cross-domain communication,
	which necessitates a wildcard SSL cert



Producers/consumers, technical details:

	"type of producer" means pull/push

	This is the object layout, "upstream" objects at top. Objects on adjacent lines
	usually know about each other.

	MinervaProtocol
	Stream
	*Transport
	(Twisted)

	When a client connects, (Twisted) causes *Transport creation,
	which causes Stream creation, which causes MinervaProtocol creation. This
	might not happen instantly, because *Transport must be authenticated first.
	At this time, there are no producers in the system.

	MinervaProtocol can at any time register or unregister a pull or push producer with Stream.

	Stream's goal is to attach the same type of producer with every S2C transport that attaches to it,
	even if the S2C transport isn't attached yet.

	Stream must also unregister producers from transports that are no longer active S2C transports.

	If type of producer is push, Stream must also call pauseProducing on MinervaProtocol whenever
	there are no active S2C transports. It must also call resumeProducing when this situation ends.

	*Transport's job is simple, it just registers itself as the correct type of producer with Twisted.
	One edge case: it must remember if Twisted paused it, and if so, pauseProducing newly-attached push producers.
