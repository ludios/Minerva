Minerva
===

The goal of Minerva is to implement a framed and extra-reliable TCP on top of
various transports:
	HTTP requests and responses (optionally HTTPSed),
	TCP connections (for now, only unencrypted due to Flash not supporting TLS socket),
	WebSocket (optionally TLSed)


Why you might want Minerva:
	You need "Comet"/"HTTP push" to push data to users, similar to meebo/google talk/google finance

	You don't really need Comet, but want your "AJAX" to be reliable and secure:
		Minerva automatically retries requests if they fail
		Minerva can use WebSocket/Flash sockets, which make it harder for
			your users to figure out what you sent over the wire with Firebug/HttpFox.
		Minerva handles the CSRF stuff, as long as you set it up right

	You don't really need Comet, but your JavaScript application needs to make a bunch of requests,
	and you would rather write this as a "real" protocol instead of a bunch of AJAX requests.

	You are writing a desktop application that needs a "real" protocol, and it must run in
	internet-hostile environments that do not even allow unmutilated socket connections over port 443.
		You can write a Minerva client that uses IE's proxy settings, or even controls a real
		IE window, to send and receive data.


Terminology:
	stream - the stateful object that protocols use to send and receive data. This is sort
		of like a TCP connection, but better in most ways.
	transport - an HTTP request/response, or socket, or WebSocket, that Minerva uses to send/receive frames.


Minerva will move heaven and earth to get your data across as efficiently and reliably as possible.
It uses streaming HTTP connections, unless it suspects a buffering proxy is in the way.
By "extra-reliable TCP" above, we meant that Minerva streams survive disconnects.
It also maintains the TCP properties of in-order and reliable data delivery.


Above, we said that Minerva is a "framed and extra-reliable TCP".
By framed, we mean that applications send and receive frames, not octets.
Why force applications to work with frames instead of octets? One might
object and say that applications need direct access to octets, but consider these points:

	Minerva's frame overhead is minimal: just 3 extra bytes for the smallest frames.

		This overhead is dwarfed by the per-packet TCP/IP overhead of ~52 bytes
		(there is even more overhead when HTTP chunk lengths or TLS are involved).

	If it worked with octets, Minerva would need to encode and decode these octets
	using base64 or similar, because:

		Over HTTP transports, NULL cannot be sent to IE or Opera.

		Minerva sometimes needs to send metadata over the transports that applications are using,
		to determine if a transport is stalled or being buffered by proxies.

	WebSocket uses frames natively, and NULLs cannot be sent over them (as of 2009-11).

	When possible, we want to avoid using JavaScript (especially IE's slow JScript) to parse frames.
	Instead we delegate this to the web browser's C++ code, or Flash's AVM2.
	
	We want to avoid using JavaScript (especially IE's slow JScript) to handle the UTF-8<->Unicode conversion.
	By requiring frames, it's an easy step to require Unicode frames, so Minerva can handle this
	instead of the application.



The frames contain semi-structured data (JSON). JSON is used as the building block
instead of "unicode strings" or similar because:
	The Minerva protocol itself does some pretty complex things and sends structured
	data. The protocol would be more complicated to change, and would require more
	code, if JSON was not the building block.

	Some environments are not unicode-safe: Firefox 2 + XHR streaming,
	or anyone with a very bad proxy. Using JSON ensures we can easily drop down to
	7-bit-clean mode. And if we're using JSON to convert ASCII to unicode, we just
	called the JSON decoder and might as well get structured data out, instead of
	just a string. But right now, Minerva always uses 7-bit-clean mode to avoid problems.

	JSON requires encoding NULL (U+0000), which is good because we cannot send it over
	all transports anyway.

	IE8, Chrome, Firefox, Safari, and Opera have native JSON encoders and decoders.
	Using JSON at the Minerva level ensures the native-JSON bugs have been abstracted
	away.

	The IE htmlfile transport automatically parses JSON as it is dumped into the HTML page,
	because it is basically executing JavaScript. Which means we don't have to dump
	a string to the page first, and then send it through a decoder.
		Counterpoint: referencing objects across windows and stashing them somewhere
		destroys object prototypes in IE, and could cause problems in other browsers.

	(in theory) In IE, using AVM2 to encode/decode JSON might be faster than eval() or json2.js,
	so Minerva can do whatever is fastest instead of requiring the application to do its own thing.

	On the server, it's slightly more efficient to have simplejson decoding at the protocol
	level, because we don't have to create many string objects first. This would not matter
	in a sane language that supported automatic in-place fragmenting of string objects. 


Problems with JSON:
	No support for dates, or sets

	Allows unlimited nesting, so you must worry about stack exhaustion. Minerva requires a
	patched simplejson that limits nesting to 32 levels.

	Because JSON allows as many keys as you want, servers have to deal with possible
	CPU-resource DoS caused by clients exploiting predictable hashing algorithms.

	The overhead of quoting every key in {"key": value} even when key is not a
	reserved word in JavaScript is annoying.

	Python dictionaries lose the order of keys in objects after decoding JSON, unless
	application tells Minerva to tell simplejson to put things in OrderedDict, which is
	slower.


Other cool Minerva features:

	Minerva can respond to TCP pressure using Twisted's producer/consumer system.
	You can easily stream megabytes of frames to a client while using little memory
	on the server. Responding to TCP pressure is useful, because it will save the client
	from having to send application-level "back off" / "ok, resume" messages.
	See section ("producers/consumers") below.

	Minerva JavaScript client: When Minerva uses HTTP transports, it tries its best to use a maximum
	of two TCP connections. Minerva understands when browsers have to open new TCP connections.

	Minerva JavaScript client: To reduce TCP connection establishment latencies, the client will avoid
	aborting HTTP connections. Because of how HTTP works, aborting an HTTP connection
	from the client necessitates closing the TCP connection.

	(planned) Minerva JavaScript client: Minerva uses "request interleaving" to reduce the gap
	where no data can be sent server->client.



Minerva limitations:

	Runs on Python, which is really slow. It's destined for a port to Factor.

	Relies on subdomains + document.domain for cross-domain communication,
	which necessitates a wildcard SSL cert

		Future: use postMessage, and Google Closure's VBScript-based transport for IE

	Minerva server ignores the selectively-acknowledged boxes in the SACK frame
	(only the primary ACK number is used)

	Minerva server does not use gzip or any other compression to compress the boxes.
	If you want the client to receive compressed data, write your client-side logic to make
	HTTP requests when necessary. These HTTP requests will hopefully be gzip-compressed.

		Future: automatic switch to gzipped HTTP S2C if there is a large volume of data to transmit.
			Procedure:
				Server-side application queues big boxes, or many boxes
				Minerva decides it would be faster to send these over a gzipped transport, even with
					the client forced to take a round-trip hit.
				Minerva server convinces the client to open an HTTP S2C transport
				Minerva server remembers that it has a lot of data to send, so this transport gets gzip headers
					and gzipped data is sent over it.
				Because the client cannot read all of the data until the HTTP request is closed, Minerva
					closes the transport fairly quickly.

				Future: See if streaming can work with HTTP by manipulating gzip blocks at a low level
					and switching them to uncompressed when needed.
					http://sys.cs.rice.edu/course/comp314/09/p2/p2-guide

		Future: zlib compression when using Flash transport
		Future: for websocket/http transports, some kind of client-side decompression inside a Web Worker 



Real-world deployment strategy that supports HTTP, Flash Socket, WebSocket:

	"ciphered" below refers to custom encryption used in Minerva to secure Flash sockets.

	A lot of users are behind firewalls that restrict connections to ports other than 80 and 443.
	Often traffic through port 80 is transparently modified. Only in rare cases is traffic through
	port 443 transparently modified, so we do not put much thought into this case.

	To allow these firewalled clients to connect, you'll want to listen for Flash Socket and
	Web Socket connections on 80 and 443, as well as other ports. If your port 443
	is already occupied by a webserver, you will need two additional public IP addresses.
	One will be listening for Flash Socket (ciphered + unencrypted) on 443. Web Socket
	(unencrypted) will be functional on this port as well. It is reasonable to serve unencrypted
	WebSocket on port 443, because this has a fighting chance of making it through an HTTPS
	CONNECT proxy [3].

	If you want Web Socket (SSL), you'll need the second additional IP. This requirement could be
	lifted [5], but it is very low priority.

	To summarize port-sharing, SSL and non-SSL listeners cannot share the same port.
	Because Flash Socket (ciphered + unencrypted) is not SSL, it shares the same port as
	WebSocket (unencrypted)

	Minerva's web resources (for long-polling/HTTP streaming) should be behind a hardened webserver
	like nginx. Compared to twisted.web, nginx is a bit harder to DoS, handles more compatibility
	problems, and maintains an SSL session cache [4]. These advantages probably
	outweigh the overhead of an open socket for every long-polling/streaming HTTP request.
	In the future, we may move more of Minerva's HTTP functionality into nginx, in the spirit
	of nginx_http_push_module [2]

	Here is a reasonable setup for a small website:

		nginx listening on ports 80 and 443 on IP0
			reverse-proxying non-static content on both ports to a Twisted server that
			is serving web resources, one of which is a newlink.HttpFace

		Twisted process running:
			newlink.HttpFace, listening on a Unix socket or TCP port for upstream
				proxy (often nginx).
			newlink.SocketFace, listening on 80, 443, 843, <extra ports> on IP1.
			newlink.SocketFace + SSL, listening on 80, 443, <extra ports> on IP2.

	Why listen on port 843? SocketFace serves Flash socket policy files when asked.
	843 is the port where Flash first looks for a Socket master policy file. [6] If Flash
	player cannot get the policy file from port 843, it will try to get the policy from the
	connection destination port. But by serving the policy on port 843, we reduce the
	time needed to establish the first connection.

		Note: 843 is used for Minerva data transmission as well, but typically only as
		a fallback. It's not restricted to just serving the policy file.

	Note that Flash Socket cannot connect to the `+ SSL' listener (right now it is just for
	WebSocket SSL), so we do not need to have SocketFace listen on port 843 on IP2.

	Optional <extra ports> for listening:
		21 (ftp), 22 (ssh), 110 (pop3), 143 (imap), 465 (SMTPs - MS),
		843 (Flash master policy port) 993 (imap+ssl), 995 (pop3+ssl)
		
		TODO: find which ports are likely to be unblocked by proxies
		TODO: test if browsers actually connect to these ports when Flash player asks


	Also, keep in mind that SSL connections will use a lot more memory compared to
	non-SSL connections. [1]

	[1] google, "occupancy of ssl connections"
	[2] http://pushmodule.slact.net/
	[3] "Most proxies disable CONNECT to anything but port 443."
		http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2008-November/017241.html
	[4] See nginx/src/event/ngx_event_openssl.c
	[5] This can be done by using Twisted's support for mem-bio SSL, but exarkun says
		this copies data a lot. An alternate approach would be to use OpenSSL's built-in
		passthrough of data when the connection doesn't look like SSL. To work with the
		standard OpenSSL, this might require changing our Minerva protocols a bit to trigger
		OpenSSL's fallback. This approach is very ugly. See http://twistedmatrix.com/trac/ticket/490
	[6] http://www.adobe.com/devnet/flashplayer/articles/fplayer9_security_04.html



Producers/consumers:

	Like twisted's TCP transport and twisted.web Requests, Minerva supports producers/consumers.
	See http://twistedmatrix.com/projects/core/documentation/howto/producers.html
	for information about them.

	In Minerva, a producer can be attached to the Stream (generally the MinervaProtocol
	attaches itself). This poses some challenges to the implementation, because Minerva
	transports may frequently attach and detach from the Stream.

	In general, TCP pressure from the TCP transport of the primary
	transport directly affects the producer attached to Stream. Also, if the producer is a push
	producer and no Minerva transports are attached the Stream, the producer is paused. 



Producers/consumers, technical details:

	"type of producer" means pull or push.

	This is the object chain, "upstream" objects at top. Objects on adjacent lines
	usually know about each other.

	MinervaProtocol
	Stream
	*Transport
	(Twisted)

	Producer attachment goes downstream, pressure information goes upstream.

	When a client connects, (Twisted) causes *Transport creation,
	which causes Stream creation, which causes MinervaProtocol creation. This
	might not happen instantly, because *Transport must be authenticated first.
	At this time, there are no producers in the system.

	MinervaProtocol can at any time register or unregister a pull or push producer with Stream.

	Stream's goal is to attach the same type of producer with every S2C transport that attaches to it,
	even if the S2C transport isn't attached yet.

	Stream must also unregister producers from transports that are no longer primary transports.

	If type of producer is push, Stream must also call pauseProducing on MinervaProtocol whenever
	there is no primary transport. It must also call resumeProducing when this situation ends.

	*Transport's job is simple, it just registers itself as the correct type of producer with Twisted.
	One edge case: it must remember if Twisted paused it, and if so, pauseProducing newly-attached push producers.

	During normal operation for a registered PULL producer, these conditions result in
	resumeProducing calls on MinervaProtocol:
		(Twisted) - [resume] when it wants more data to send

	During normal operation for a registered PUSH producer, these conditions result in
	pauseProducing or resumeProducing calls on MinervaProtocol:
		(Twisted) - [resume] when it wants more data to send
		(Twisted) - [pause] when it has enough data
		*Transport - [pause] if it was paused earlier by (Twisted)
		Stream - [pause] when there are no primary transports
		Stream - If paused, [resume] when a primary transport appears
